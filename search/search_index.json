{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Java JSON Parser"},{"location":"/index.html#java-json-parser","text":"This Java library provides a JSON parser. The parser reads a JSON text, parses it in accordance with RFC 8259 and creates a corresponding data structure with Java objects.\nThe main feature of this library is that it keeps the original JSON text information in the Java objects. Therefore, for example, your application can show where exactly (line number & column number) the JSON text has a problem if there is a semantic error.\nIf the given JSON text includes a syntax error, this library shows an error message with line and column numbers so that the users will be able to know where exactly the problem is. This library is suitable to parse configuration files in JSON that the users manually write. The error message can be customized by option switches. See parser error handling options for more details.","title":"Java JSON Parser"},{"location":"/index.html#setup","text":"Add the following dependency to your build file:\nMaven <dependency>\n  <groupId>com.github.tnakamot</groupId>\n  <artifactId>json-parser</artifactId>\n  <version>0.2.1</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.github.tnakamot', name: 'json-parser', version: '0.2.1'\n} sbt libraryDependencies += \"com.github.tnakamot\" % \"json-parser\" % \"0.2.1\"","title":"Setup"},{"location":"/index.html#usage","text":"Import the following packages in your Java source code.\nimport com.github.tnakamot.json.JSONText;\nimport com.github.tnakamot.json.value.*;\nThen, instantiate JSONText and call parse(). root().\nJSONText jsText = JSONText.fromString(\n        \" { \\\"key1\\\": \\\"value\\\", \" +\n        \"   \\\"key2\\\": 1.53, \" +\n        \"   \\\"key3\\\": true,\" +\n        \"   \\\"key4\\\": null } \");\nJSONValue root = jsText.parse().root();\nThe root JSON value can be obtained as an instance of JSONValue.\nTypically, the type of the root JSON value is “object”. Check the type of the root value, and cast it to JSONValueObject. Then, you will be able to get values as shown below.\nif (root.type() == JSONValueType.OBJECT) {\n    JSONValueObject rootObject = (JSONValueObject) root;\n\n    JSONValue value1 = rootObject.get(\"key1\");\n    if (value1.type() == JSONValueType.STRING) { \n        String value1Str = ((JSONValueString) value1).value();\n        System.out.println(value1Str);\n    }\n\n    JSONValue value2 = rootObject.get(\"key2\");\n    if (value2.type() == JSONValueType.NUMBER) { \n        double value2Dbl = ((JSONValueNumber) value2).toDouble();\n        System.out.println(value2Dbl);\n    }\n\n    JSONValue value3 = rootObject.get(\"key3\");\n    if (value3.type() == JSONValueType.BOOLEAN) {\n        boolean value3Bool = ((JSONValueBoolean) value3).value();\n        System.out.println(value3Bool);\n    }\n\n    JSONValue value4 = rootObject.get(\"key4\");\n    if (value4.type() == JSONValueType.NULL) {\n        System.out.println(\"null\");\n    }\n}","title":"Usage"},{"location":"/index.html#convenience-methods","text":"If you already know the data structure and data types exactly, your Java program call convenience methods getXxxx() like shown below.\nJSONText jsText = JSONText.fromString(\n        \" { \\\"key1\\\": \\\"value\\\", \" +\n        \"   \\\"key2\\\": 3.14, \" +\n        \"   \\\"key3\\\": false,\" +\n        \"   \\\"key4\\\": 1024,\" +\n        \"   \\\"key5\\\": [5, 1, 2], \"+\n        \"   \\\"key6\\\": {\\\"key6-1\\\": 0} }\");\nJSONValueObject root = (JSONValueObject) jsText.parse().root();\n\nString  value1Str = root.getString(\"key1\");\nSystem.out.println(value1Str);\n\ndouble value2Dbl = root.getDouble(\"key2\");\nSystem.out.println(value2Dbl);\n\nboolean value3Bool = root.getBoolean(\"key3\");\nSystem.out.println(value3Bool);\n\nlong value4Lng = root.getLong(\"key4\");\nSystem.out.println(value4Lng);\n\nJSONValueArray value5Arr = root.getArray(\"key5\");\nSystem.out.println(value5Arr.getLong(0));\nSystem.out.println(value5Arr.getLong(1));\nSystem.out.println(value5Arr.getLong(2));\n\nJSONValueObject value6Obj = root.getObject(\"key6\");\nSystem.out.println(value6Obj.getLong(\"key6-1\"));","title":"Convenience methods"},{"location":"/types.html","text":"","title":"Types"},{"location":"/types.html#types","text":"JSONValue is an abstract class, and child classes represent actual JSON values. Call type() to get the type of the JSON value you have. The returned type tells you to which dedicated class you can cast the instance of JSONValue safely. The table below shows the correspondence between the type returned by type() and the class which you can cast to.\nType Class NULL JSONValueNull BOOLEAN JSONValueBoolean STRING JSONValueString NUMBER JSONValueNumber ARRAY JSONValueArray OBJECT JSONValueObject\nInstead of checking the value returned by type(), you can also use instanceof operator.\nThe following sections explain the details of each type.","title":"Types"},{"location":"/types.html#null","text":"JSONValueNull has no value.","title":"null"},{"location":"/types.html#boolean","text":"JSONValueBoolean holds a boolean value. Call value() to extract the boolean value.","title":"boolean"},{"location":"/types.html#string","text":"JSONValueString holds an unescaped string value. Call value() to extract the string value.","title":"string"},{"location":"/types.html#number","text":"JSONValueNumber holds a number value as String. Unfortunately, no Java class in the standard Java library can represent all possible numeric values that the JSON number notation can express without information loss.\nRFC 8259 - 6. Numbers explains all possible numeric expressions in JSON. It allows an extremely large value like 1E100000, and an extremely precise value like 3.14159265358979323846264338327950288. Although the RFC 8259 allows libraries and applications to set limits on the range and precision of numbers accepted, this library does not set such limits to maximize interoperability. JSONValueNumber of this library holds each numeric value in a string as it appears in your original JSON text.\nFor your convenience, you can call toDouble() or toLong() to get a corresponding Java primitive value.\ntoDouble() internally calls Double.parseDouble(String). As far as the library author knows, this method does not throw an exception as long as you pass a valid JSON numeric expression. However, you loose information if you pass an extremely precise value, and you will get POSITIVE_INFINITY or NEGATIVE_INFINITY if you pass an extremely large value.\ntoLong() tries to convert the String representation of the JSON numeric value into long, but if it cannot convert without loosing information, it throws NumberFormatException. For example, 1.52e2 appears to be a floating point value, but it is actually an integer 152. Therefore, toLong() returns 152. However, if there is a fractional part (e.g. 1.523e2), or if the value is too large (e.g. 9223372036854775808), this method throws NumberFormatException.","title":"number"},{"location":"/types.html#array","text":"JSONValueArray holds an ordered sequence of JSONValue. It implements List interface, so all values can be iterated using for statement, for example.\nJSONText jsText = JSONText.fromString(\" [ true, false, \\\"abc\\\", 1.52, null ] \");\nJSONValue root = jsText.parse().root();\n\nif (root.type() == JSONValueType.ARRAY) {\n    JSONValueArray rootArray = (JSONValueArray) root;\n\n    for (JSONValue jsonValue : rootArray) {\n        ...\n    }\n}","title":"array"},{"location":"/types.html#object","text":"JSONValueObject holds a key-value map. It implements Map interface. The class of the key is JSONValueString and that of the value is JSONValue. All key-value pairs can be iterated as shown below.\nJSONText jsText = JSONText.fromString(\n    \" { \\\"key1\\\": true, \" +\n    \"   \\\"key2\\\": false,\" +\n    \"   \\\"key3\\\": null } \");\nJSONValue root = jsText.parse();\n\nif (root.type() == JSONValueType.OBJECT) {\n    JSONValueObject rootObj = (JSONValueObject) root;\n\n    for (Map.Entry<JSONValueString, JSONValue> entry: rootObj.entrySet()) {\n        JSONValueString key = entry.getKey();\n        JSONValue value = entry.getValue();\n        ...\n    }\n}","title":"object"},{"location":"/immutable.html","text":"","title":"Immutable and Mutable"},{"location":"/immutable.html#immutable-and-mutable","text":"All instances of JSONValue that correspond to JSON primitive values (null, boolean, string and number) are immutable. In other words, instances of JSONValueNull, JSONValueBoolean, JSONValueString and JSONValueNumber are immutable. Multiple threads can safely access those instance at a time.\nOn the other hands, the structure types (array and object) have immutable and mutable versions. JSONValueArray and JSONValueObject are abstract classes. The actual implementations of these abstract classes are JSONValueArrayImmutable, JSONValueArrayMutable, JSONValueObjectImmutable and JSONValueObjectMutable.\nInvocation of any method that may change the contents (e.g. add() and put()) result in UnsupportedOperationException if it is immutable.","title":"Immutable and Mutable"},{"location":"/immutable.html#parser","text":"parse() and its varaitns always result in an immutable instance.","title":"Parser"},{"location":"/immutable.html#conversion","text":"You can get a mutable copy of an immutable JSON object or array with following methods:\nJSONValueArrayImmutable#toMutable() JSONValueObjectImmutable#toMutable()\nBelow are reverse methods:\nJSONValueArrayMutable#toImutable() JSONValueObjectMutable#toImutable()\nThese methods turn inner JSON objects and arrays to immutable or mutable, too. For example, if there is a mutable JSON object which contains two mutable JSON arrays, JSONValueObjectImmutable#toMutable() turns the given JSON object and two inner JSON arrays to immutable.","title":"Conversion"},{"location":"/json_source.html","text":"","title":"Load JSON text from various sources"},{"location":"/json_source.html#load-json-text-from-various-sources","text":"JSON text can be loaded from various sources.","title":"Load JSON text from various sources"},{"location":"/json_source.html#local-file","text":"JSONText jsText = JSONText.fromFile(new File(\"/path/to/file.json\"));","title":"Local file"},{"location":"/json_source.html#url","text":"JSONText jsText = JSONText.fromURL(new URL(\"http://example.jp/test.json\"))","title":"URL"},{"location":"/json_source.html#string","text":"JSONText jsText = JSONText.fromString(\n        \" { \\\"key1\\\": true, \" +\n        \"   \\\"key2\\\": false,\" +\n        \"   \\\"key3\\\": null } \");\nThe above example does not specify the source name. For better user experience, it is recommended to specify the source name of the JSON text by calling fromString(String, String). The second string parameter specifies the name. This name will be shown when the parser encounters a syntax error. For example, the code below results in JSONParserException (because the string value is not enclosed by double quotes).\nString text = \"{ \\\"key\\\": value }\";\nJSONText source = JSONText.fromString(text, \"text_in_memory.json\");\nJSONValue value root = source.parse().root();\nAs this example sets the source name to “text_in_memory.json”, the error message of the exception is shown as follows.\ntext_in_memory.json:1:10: unknown token starting with 'v'\nFrom this error message, the user can quickly know the error is in the 10th character of line 1 in text_in_memory.json. Therefore, it is highly recommended specifying the name that the user of your application can understand.","title":"String"},{"location":"/source_info.html","text":"","title":"JSON source information"},{"location":"/source_info.html#json-source-information","text":"","title":"JSON source information"},{"location":"/source_info.html#primitive-types","text":"The advantage of this library is that each primitive JSON value (string, number, boolean, null) hold where it originates from. To obtain that information, call token().\nJSONValueString jsStr = ...;\nJSONToken token = jsStr.token();\nAn instance of JSONToken holds following information.\nbeginningLocation() returns an object which holds the line and column number of the first character of this JSON value within the JSON text. endLocation() returns an object which holds the line and column number of the character of the last character of this JSON value within the JSON text. source() returns an instance of JSONText from which the parser extracted the JSON value. JSONText#name() holds the short name of the JSON text. In many cases, it returns a file name. JSONText#uri() holds the URI of the JSON text.\nJSONValue root =\n    JSONText.fromString(\"{\\\"key1\\\": 1.23, \\\"key2\\\": \\\"te\\\\nst\\\" }\").parse().root();\n\nJSONValueObject rootObj = (JSONValueObject) root;\nJSONValueString str = (JSONValueString) rootObj.get(\"key2\");\nJSONToken token = str.token();\n\nSystem.out.println(\"Token: \" + token.text());\nSystem.out.println(\n    String.format(\n        \"Start: line %d, column %d\",\n        token.beginningLocation().line(),\n        token.beginningLocation().column()));\nSystem.out.println(\n    String.format(\n        \"End  : line %d, column %d\",\n        token.endLocation().line(),\n        token.endLocation().column()));","title":"Primitive Types"},{"location":"/source_info.html#structured-types","text":"Structured values (array and object) also hold the source information. by calling begin() and end(). Those methods basically return the token informaiton about {, }, [ and ].\nJSONValue root =\n    JSONText.fromString(\"{\\\"key1\\\": [true, 123]}\").parse().root();\nJSONValueObject rootObj = (JSONValueObject) root;\n\nJSONToken begin = rootObj.begin();\nJSONToken end = rootObj.end();\n\nString msgBegin =\n    String.format(\n        \"%s at line %d, column %d\",\n        begin.text(),\n        begin.beginningLocation().line(),\n        begin.beginningLocation().column());\nSystem.out.println(msgBegin);\n\nString msgEnd =\n    String.format(\n        \"%s at line %d, column %d\",\n        end.text(),\n        end.beginningLocation().line(),\n        end.beginningLocation().column());\nSystem.out.println(msgEnd);\nWarning token(), begin() and end() return null if the JSON value does not originate from an instance of JSONText. For example, if your application creates new instances of JSON values to generate a new JSON text, they do not hold a source information.","title":"Structured Types"},{"location":"/parser_options.html","text":"","title":"Parser error handling options"},{"location":"/parser_options.html#parser-error-handling-options","text":"You can control some error handling behavior of the parser by calling JSONText#parse(JSONParserErrorHandlingOptions). JSONParserErrorHandlingOptions is a class to hold options to control the error handling behavior. It follows Builder Pattern. Below is an example to set options.\nJSONParserErrorHandlingOptions opt =\n    JSONParserErrorHandlingOptions.builder()\n         .showURI(false)\n         .showLineAndColumnNumber(true)\n         .showErrorLine(false)\n         .failOnDuplicateKey(false)\n         .failOnTooBigNumber(false)\n         .warningStream(System.err)\n         .build();\nFollowing sections explais each option.","title":"Parser error handling options"},{"location":"/parser_options.html#showuri","text":"If showURI option is true, the error message shows the URI of the JSON text which has an error. If it is false, it shows only a short name, which is typically a file name.\nHere is an example code.\nJSONParserErrorHandlingOptions options =\n     JSONParserErrorHandlingOptions.builder().showURI(true).build();\nString url = \"http://localhost:8215/json/invalid1.json\";\nJSONText jsText = JSONText.fromURL(new URL(url));\njsText.parse(options);\nGiven that http://localhost:8215/json/invalid1.json has an error at line 3 and column 12, the above code results in this error message.\nhttp://localhost:8215/json/invalid1.json:3:12: unknown token starting with 'x'\nIf showURI option is false, the error message becomes.\ninvalid1.json:3:12: unknown token starting with 'x'","title":"showURI"},{"location":"/parser_options.html#showlineandcolumnnumber","text":"If showLineAndColumnNumber option is true, the error message shows the line and column numbers. If it is false, it shows the character position instead.\nHere is an example code.\nString jsonStr = \n    \"[\\n\"+\n    \"  123,\\n\" +\n    \"  ff,\\n\" +\n    \"]\";\n\nJSONParserErrorHandlingOptions options =\n    JSONParserErrorHandlingOptions.builder()\n        .showLineAndColumnNumber(true)\n        .build();\n\nJSONText jsText = JSONText.fromString(jsonStr, \"test.json\");\njsText.parse(options);\nThis example code results in this error message.\ntest.json:3:3: unknown token starting with 'ff'\nIf showLineAndColumnNumber option is false, the error message becomes:\ntest.json:11: unknown token starting with 'ff'\nNote The line and column numbers start with 1 while the character position starts with 0.","title":"showLineAndColumnNumber"},{"location":"/parser_options.html#showerrorline","text":"If showErrorLine option is true, the error message shows the line that has an error with markers to indicate where is the problem.\nHere is an example.\nString jsonStr =\n    \"{\\n\" +\n    \"  \\\"key1\\\" true,\\n\" +\n    \"  \\\"key2\\\": false\\n\" +\n    \"}\";\n\nJSONParserErrorHandlingOptions options =\n    JSONParserErrorHandlingOptions.builder()\n        .showErrorLine(true)\n        .build();\n\nJSONText jsText = JSONText.fromString(jsonStr, \"test.json\");\njsText.parse(options);\nThis example code result in this error message.\ntest.json:2:10: Unexpected token 'true'. ':' was expected.\n  \"key1\" true,\n         ^^^^\nIf showErrorLine is false, it shows only the error message like below:\ntest.json:2:10: Unexpected token 'true'. ':' was expected.","title":"showErrorLine"},{"location":"/parser_options.html#failonduplicatekey","text":"If failOnDuplicateKey option is true and there are duplicate keys in the same JSON object, the parser results in JSONParserException.\nHere is an example.\nJSONParserErrorHandlingOptions opt =\n    JSONParserErrorHandlingOptions.builder()\n        .showErrorLine(true)\n        .failOnDuplicateKey(true)\n        .build();\n\nJSONText jsText =\n    JSONText.fromString(\n        \"{\" +\n        \" \\\"key1\\\": true,\\n\" +\n        \" \\\"key2\\\": false,\\n\" +\n        \" \\\"key1\\\": null,\\n\" +\n        \" \\\"key1\\\": false,\\n\" +\n        \" \\\"key2\\\": null\\n\" +\n        \"}\", \"test.json\");\n\njsText.parse(opt);\nThis example code ends up with JSONParserException and the following error message.\ntest.json:3:2: Found duplicate key 'key1' in the same JSON object.\n \"key1\": null,\n ^^^^^^\nIf failOnDuplicateKey option is false, this library retains only the last value of the same key. In the above example but with failOnDuplicateKey being false, the resultant JSON object returns false for “key1” and null for “key2”.\nIf failOnDuplicateKey option is false, this library warns of duplicate keys in the standard error by default. The destination of the warning message can be changed by warningStream option.","title":"failOnDuplicateKey"},{"location":"/parser_options.html#failontoobignumber","text":"If failOnTooBigNumber option is true and there is one or more numbers that are not in the range between (-253 + 1) and (253 - 1), the parser results in JSONParserException.\nHere is an example.\nJSONParserErrorHandlingOptions opt =\n    JSONParserErrorHandlingOptions.builder()\n        .showErrorLine(true)\n        .failOnTooBigNumber(true)\n        .build();\n\nJSONText jsText =\n    JSONText.fromString(\n        \"{\\\"key1\\\": 1.52, \\\"key2\\\": 9007199254740992, \\\"key3\\\": null}\",\n        \"test_double.json\");\n\njsText.parse(opt);\nThis example code ends up with JSONParserException and the following error message.\ntest_double.json:1:24: '9007199254740992' is not in the range [-(2^53)+1, 2^53-1]\n{\"key1\": 1.52, \"key2\": 9007199254740992, \"key3\": null}\n                       ^^^^^^^^^^^^^^^^\nIf failOnDuplicateKey option is false, this library warns of too big numbers in the standard error by default. The destination of the warning message can be changed by warningStream option.\nNote This option is to enforce the users not to use integer numbers that cannot be handled by a double-precision floating point value without information loss. This library itself handles JSON numbers in a string, so no information loss will occur unless your application converts them to another numeric type like ‘double’. In many cases, application programs convert a JSON number in a double-precisiong floating point value. If your application program wants to do so, this option helps.","title":"failOnTooBigNumber"},{"location":"/parser_options.html#warningstream","text":"This option changes the output destination of warning messages. If you want to show the warning messages to a standard output, build the option with the following example code.\nJSONParserErrorHandlingOptions opt =\n    JSONParserErrorHandlingOptions.builder()\n         .warningStream(System.out)\n         .build();\nBelow is an example warning output which is shown if failOnDuplicateKey is false in the example code in failOnDuplicateKey.\ntest.json: duplicate key 'key1': \n  At line 1, column 3 - 8\n    { \"key1\": true,\n      ^^^^^^\n  At line 3, column 2 - 7\n     \"key1\": null,\n     ^^^^^^\n  At line 4, column 2 - 7\n     \"key1\": false,\n     ^^^^^^\ntest.json: duplicate key 'key2': \n  At line 2, column 2 - 7\n     \"key2\": false,\n     ^^^^^^\n  At line 5, column 2 - 7\n     \"key2\": null\n     ^^^^^^","title":"warningStream"},{"location":"/output.html","text":"","title":"Output JSON text"},{"location":"/output.html#output-json-text","text":"JSONValue has the following methods to output JSON text.\ntoTokenBytes toTokenBytes(String newline, String indent) toTokenString toTokenString(String newline, String indent)\nThere are two versions for each method; one with no argument outputs a JSON text which does not include any white spaces or new line characters. It is suitable if the output will be processed by another program or library.\nThe other version has two arguments. This method is suitable for human-reading because it adds new lines and indent accordingly. You need to specify the new line character(s) and indent.\ntoTokenString methods return a String. It is the caller’s responsibility to encode the returned String. According to RFC 8259 - 8.1 Character Encoding, your application must encode it using UTF-8 without BOM before saving them to a file or transmitted to a network.\ntoTokenBytes methods return a byte array. The returned byte array contains the JSON text encoded in UTF-8 without BOM.","title":"Output JSON text"},{"location":"/output.html#examples","text":"Let’s assume you constructed a JSON data structure with the code below and output the text with the last line where you specified ‘\\n’ as the new line character and two white spaces as indent.\nJSONValueObjectMutable obj = new JSONValueObjectMutable();\nobj.put(\"key1\", new JSONValueNumber(\"123\"));\nobj.put(new JSONValueString(\"key2\"), new JSONValueNumber(\"789\"));\nSystem.out.println(obj.toTokenString(\"\\n\", \"  \"));\nThen, you will get this result.\n{\n  \"key1\": 123,\n  \"key2\": 789\n}\nIf you do not specify new line or indent like this code,\nSystem.out.println(obj.toTokenString());\nthen you will get this one line result.\n{\"key1\":123,\"key2\":789}","title":"Examples"},{"location":"/json_pointer.html","text":"","title":"JSON Pointer"},{"location":"/json_pointer.html#json-pointer","text":"This library also implements JSON Pointer in accorance with RFC 6901.\nTo get a JSON value using a JSON Pointer, call JSONText#evaluate(String). Below is an example.\nJSONText jsText = JSONText.fromString(\n        \"{\" +\n        \"  \\\"key1\\\": \\\"value\\\", \" +\n        \"  \\\"key2\\\": [3, 1, 4], \" +\n        \"  \\\"key3\\\": true,\" +\n        \"  \\\"key4\\\": {\\\"key5\\\": \\\"hello!\\\" }\" +\n        \"} \");\n    JSONValue root = jsText.parse().root();\n\n    JSONValueString val1 = (JSONValueString) jsText.evaluate(\"/key1\");\n    System.out.println(val1.value());\n\n    JSONValueNumber val2 = (JSONValueNumber) jsText.evaluate(\"/key2/1\");\n    System.out.println(val2.toLong());\n\n    JSONValueString val3 = (JSONValueString) jsText.evaluate(\"/key4/key5\");\n    System.out.println(val3.value());\nNote Before your application calls evaluate(String) or its variant, it needs to explicitly call parse() or its variant and the JSON test must be parsed successfully. This is the design choice to allow your application code to separately handle possible exceptions caused by the JSON parser. Your application typically needs to call parse() only once and may evaluate JSON Pointers many times after that. You do not want to handle exceptions that may be caused by the JSON parser every time this library evaluates a JSON Pointer. If you want to make sure the JSON text has been parsed, your application may call isParsed() and call parse() if it has not been parsed.","title":"JSON Pointer"},{"location":"/json_pointer.html#uri-fragment-identifier-representation","text":"RFC 6901 - 6. URI Fragment Identifier Representation allows us to represent a JSON Pointer in a URI fragment identifier, which is a text starting from ‘#’ (0x23). Normally, JSON Pointer looks like /key1/5/key2. In URI fragment identifier, it turns to be #/key1/5/key2. However, RFC 6901 asks the application programs and libraries to check the media type (e.g. application/json) to judge if the JSON Pointer should be handled as a URI fragment identifier.\nThis library does not obtain the media type from the JSON text source because local file system does not typically provide it. Instead, your application programs to judge if JSON Pointers should be handled a URI fragment identifier. Once judged, pass true to the second argument of evaluate(String, boolean). Then, this library considers the given JSON Pointer as a URI fragument identifier, strips the first “#” (0x23) and evaluates the JSON Pointer in the normal way.","title":"URI Fragment Identifier Representation"},{"location":"/source.html","text":"","title":"Source Code"},{"location":"/source.html#source-code","text":"The source code of this library is available at GitHub.","title":"Source Code"},{"location":"/javadoc.html","text":"","title":"Javadoc"},{"location":"/javadoc.html#javadoc","text":"Javadoc of the latest version is available here.\nJavadoc of old versions is available as jar files in Maven Repository. For example, the javadoc jar file of version 0.0.6 can be found here.","title":"Javadoc"}]}