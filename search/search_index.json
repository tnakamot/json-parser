{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Java JSON Parser"},{"location":"/index.html#java-json-parser","text":"This Java library provides a JSON parser. The parser reads a JSON text, parses it in accordance with RFC 8259 and creates a corresponding data structure with Java objects.\nThe main feature of this library is that it keeps the original JSON text information in the Java objects. Therefore, for example, your application can show where exactly (line number & column number) the JSON text has a problem if there is a semantic error.","title":"Java JSON Parser"},{"location":"/index.html#setup","text":"Add the following dependency to your build file:\nMaven <dependency>\n  <groupId>com.github.tnakamot</groupId>\n  <artifactId>json-parser</artifactId>\n  <version>0.2.0</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.github.tnakamot', name: 'json-parser', version: '0.2.0'\n} sbt libraryDependencies += \"com.github.tnakamot\" % \"json-parser\" % \"0.2.0\"","title":"Setup"},{"location":"/index.html#usage","text":"Import the following packages in your Java source code.\nimport com.github.tnakamot.json.JSONText;\nimport com.github.tnakamot.json.value.*;\nThen, instantiate JSONText and call parse().\nJSONText jsText = JSONText.fromString(\n        \" { \\\"key1\\\": \\\"value\\\", \" +\n        \"   \\\"key2\\\": 1.53, \" +\n        \"   \\\"key3\\\": true,\" +\n        \"   \\\"key4\\\": null } \");\nJSONValue root = jsText.parse();\nThe root JSON value can be obtained as an instance of JSONValue.\nTypically, the type of the root JSON value is “object”. Check the type of the root value, and cast it to JSONValueObject. Then, you will be able to get values as shown below.\nif (root.type() == JSONValueType.OBJECT) {\n    JSONValueObject rootObject = (JSONValueObject) root;\n\n    JSONValue value1 = rootObject.get(\"key1\");\n    if (value1.type() == JSONValueType.STRING) { \n        String value1Str = ((JSONValueString) value1).value();\n        System.out.println(value1Str);\n    }\n\n    JSONValue value2 = rootObject.get(\"key2\");\n    if (value2.type() == JSONValueType.NUMBER) { \n        double value2Dbl = ((JSONValueNumber) value2).toDouble();\n        System.out.println(value2Dbl);\n    }\n\n    JSONValue value3 = rootObject.get(\"key3\");\n    if (value3.type() == JSONValueType.BOOLEAN) {\n        boolean value3Bool = ((JSONValueBoolean) value3).value();\n        System.out.println(value3Bool);\n    }\n\n    JSONValue value4 = rootObject.get(\"key4\");\n    if (value4.type() == JSONValueType.NULL) {\n        System.out.println(\"null\");\n    }\n}","title":"Usage"},{"location":"/index.html#more-simple-usage","text":"If you already know the data structure and data types exactly, your Java program can be concise using convenience getXxxx() methods like shown below.\nJSONText jsText = JSONText.fromString(\n        \" { \\\"key1\\\": \\\"value\\\", \" +\n        \"   \\\"key2\\\": 3.14, \" +\n        \"   \\\"key3\\\": false,\" +\n        \"   \\\"key4\\\": 1024,\" +\n        \"   \\\"key5\\\": [5, 1, 2], \"+\n        \"   \\\"key6\\\": {\\\"key6-1\\\": 0} }\");\nJSONValueObject root = (JSONValueObject) jsText.parse();\n\nString  value1Str = root.getString(\"key1\");\nSystem.out.println(value1Str);\n\ndouble value2Dbl = root.getDouble(\"key2\");\nSystem.out.println(value2Dbl);\n\nboolean value3Bool = root.getBoolean(\"key3\");\nSystem.out.println(value3Bool);\n\nlong value4Lng = root.getLong(\"key4\");\nSystem.out.println(value4Lng);\n\nJSONValueArray value5Arr = root.getArray(\"key5\");\nSystem.out.println(value5Arr.getLong(0));\nSystem.out.println(value5Arr.getLong(1));\nSystem.out.println(value5Arr.getLong(2));\n\nJSONValueObject value6Obj = root.getObject(\"key6\");\nSystem.out.println(value6Obj.getLong(\"key6-1\"));","title":"More simple usage"},{"location":"/types.html","text":"","title":"Types"},{"location":"/types.html#types","text":"JSONValue is an abstract class, and child classes represent actual JSON values. Call type() to get the type of the JSON value you have. The returned type tells you to which dedicated class you can cast the instance of JSONValue safely. The table below shows the correspondence between the type returned by type() and the class which you can cast to.\nType Class NULL JSONValueNull BOOLEAN JSONValueBoolean STRING JSONValueString NUMBER JSONValueNumber ARRAY JSONValueArray OBJECT JSONValueObject\nInstead of checking the value returned by type(), you can also use instanceof operator.\nThe following sections explain the details of each type.","title":"Types"},{"location":"/types.html#null","text":"JSONValueNull has no value.","title":"null"},{"location":"/types.html#boolean","text":"JSONValueBoolean holds a boolean value. Call value() to extract the boolean value.","title":"boolean"},{"location":"/types.html#string","text":"JSONValueString holds an unescaped string value. Call value() to extract the string value.","title":"string"},{"location":"/types.html#number","text":"JSONValueNumber holds a number value as String. Unfortunately, no Java class in the standard Java library can represent all possible numeric values that the JSON number notation can express without information loss.\nRFC 8259 - 6. Numbers explains all possible numeric expressions in JSON. It allows an extremely large value like 1E100000, and an extremely precise value like 3.14159265358979323846264338327950288. Although the RFC 8259 allows libraries and applications to set limits on the range and precision of numbers accepted, this library does not set such limits to maximize interoperability. JSONValueNumber of this library holds each numeric value in a string as it appears in your original JSON text.\nFor your convenience, you can call toDouble() or toLong() to get a corresponding Java primitive value.\ntoDouble() internally calls Double.parseDouble(String). As far as the library author knows, this method does not throw an exception as long as you pass a valid JSON numeric expression. However, you loose information if you pass an extremely precise value, and you will get POSITIVE_INFINITY or NEGATIVE_INFINITY if you pass an extremely large value.\ntoLong() tries to convert the String representation of the JSON numeric value into long, but if it cannot convert without loosing information, it throws NumberFormatException. For example, 1.52e2 appears to be a floating point value, but it is actually an integer 152. Therefore, toLong() returns 152. However, if there is a fractional part (e.g. 1.523e2), or if the value is too large (e.g. 9223372036854775808), this method throws NumberFormatException.","title":"number"},{"location":"/types.html#array","text":"JSONValueArray holds an ordered sequence of JSONValue. It implements List interface, so all values can be iterated using for statement, for example.\nJSONText jsText = JSONText.fromString(\" [ true, false, \\\"abc\\\", 1.52, null ] \");\nJSONValue root = jsText.parse();\n\nif (root.type() == JSONValueType.ARRAY) {\n    JSONValueArray rootArray = (JSONValueArray) root;\n\n    for (JSONValue jsonValue : rootArray) {\n        ...\n    }\n}","title":"array"},{"location":"/types.html#object","text":"JSONValueObject holds a key-value map. It implements Map interface. The class of the key is JSONValueString and that of the value is JSONValue. All key-value pairs can be iterated as shown below.\nJSONText jsText = JSONText.fromString(\n    \" { \\\"key1\\\": true, \" +\n    \"   \\\"key2\\\": false,\" +\n    \"   \\\"key3\\\": null } \");\nJSONValue root = jsText.parse();\n\nif (root.type() == JSONValueType.OBJECT) {\n    JSONValueObject rootObj = (JSONValueObject) root;\n\n    for (Map.Entry<JSONValueString, JSONValue> entry: rootObj.entrySet()) {\n        JSONValueString key = entry.getKey();\n        JSONValue value = entry.getValue();\n        ...\n    }\n}","title":"object"},{"location":"/immutable.html","text":"","title":"Immutable and Mutable"},{"location":"/immutable.html#immutable-and-mutable","text":"All instances of JSONValue that correspond to JSON primitive values (null, boolean, string and number) are immutable. In other words, instances of JSONValueNull, JSONValueBoolean, JSONValueString and JSONValueNumber are immutable. Multiple threads can safely access those instance at a time.\nOn the other hands, the structures types (array and object) have immutable and mutable versions. JSONValueArray and JSONValueObject are abstract classes. The actual implementations of these abstract classes are JSONValueArrayImmutable, JSONValueArrayMutable, JSONValueObjectImmutable and JSONValueObjectMutable.\nInvocation of any method that may change the contents (e.g. add() and put()) result in UnsupportedOperationException if it is immutable.","title":"Immutable and Mutable"},{"location":"/immutable.html#parser","text":"When you parse the JSON text, you can specify whether the parser should return immutable or mutable version. parse(boolean) method of JSONText takes a boolean value.\nIf it is true, the method returns the immutable version, which is suitable to load configuration in JSON text in memory, for example.\nIf it is false, the method returns the mutable version. The mutable version allows you to add, remove and modify the contents in JSON objects and arrays. The mutable version is suitable, for example, if your application needs to read a JSON text from a file, modify the contents and write back to another file.","title":"Parser"},{"location":"/immutable.html#conversion","text":"You can get a mutable copy of an immutable JSON object or array and get an immutable copy of a mutable version with the following methods\nJSONValueArrayImmutable#toMutable() JSONValueObjectImmutable#toMutable() JSONValueArrayMutable#toImutable() JSONValueObjectMutable#toImutable()\nThese methods turn the inner JSON objects and arrays to immutable or mutable. For example, if there is a mutable JSON object which contains two mutable JSON arrays, JSONValueObjectImmutable#toMutable() turns the given JSON object and two JSON arrays to immutable.","title":"Conversion"},{"location":"/json_source.html","text":"","title":"Load JSON text from various sources"},{"location":"/json_source.html#load-json-text-from-various-sources","text":"JSON text can be loaded from various sources.","title":"Load JSON text from various sources"},{"location":"/json_source.html#local-file","text":"JSONText jsText = JSONText.fromFile(new File(\"/path/to/file.json\"));","title":"Local file"},{"location":"/json_source.html#url","text":"JSONText jsText = JSONText.fromURL(new URL(\"http://example.jp/test.json\"))","title":"URL"},{"location":"/json_source.html#string","text":"JSONText jsText = JSONText.fromString(\n        \" { \\\"key1\\\": true, \" +\n        \"   \\\"key2\\\": false,\" +\n        \"   \\\"key3\\\": null } \");\nThe above example does not specify the source name. For better user experience, it is recommended to specify the source name of the JSON text by calling fromString(String, String). The second string parameter specifies the name. This name will be shown when the parser encounters a syntax error. For example, the code below results in JSONParserException (because the string value is not enclosed by double quotes).\nString text = \"{ \\\"key\\\": value }\";\nJSONText source = JSONText.fromString(text, \"text_in_memory.json\");\nJSONValue value root = source.parse()\nAs this example sets the source name to “text_in_memory.json”, the error message of the exception is shown as follows.\ntext_in_memory.json:1:10: unknown token starting with 'v'\nFrom this error message, the user can quickly know the error is in the 10th character of line 1 in text_in_memory.json. Therefore, it is highly recommended specifying the name that the user of your application can understand.","title":"String"},{"location":"/source_info.html","text":"","title":"JSON source information"},{"location":"/source_info.html#json-source-information","text":"The advantage of this library is that each primitive JSON value hold where it is originated from. To obtain that information, call token().\nJSONValueString jsStr = ...;\nJSONToken token = jsStr.token();\nAn instance of JSONToken holds following information.\nbeginningLocation() returns an object which holds the line and column number of the first character of this JSON value within the JSON text. endLocation() returns an object which holds the line and column number of the character after the last character of this JSON value within the JSON text. source() returns an instance of JSONText from which the parser extracted the JSON value. JSONText#name() holds the short name (i.e. file name) of the JSON text. JSONText#fullName() holds the full name (i.e. URL or full path) of the JSON text. The above methods do not make sense if you loaded the JSON text from String.","title":"JSON source information"},{"location":"/output.html","text":"","title":"Output JSON text"},{"location":"/output.html#output-json-text","text":"JSONValue has the following methods to output JSON text.\ntoTokenBytes toTokenBytes(String newline, String indent) toTokenString toTokenString(String newline, String indent)\nThere are two versions for each method; one with no argument outputs a JSON text which does not include any white spaces or new line characters. It is suitable if the output will be processed by another program or library.\nThe other version has two arguments. This method is suitable for human-reading because it adds new lines and indent accordingly. You need to specify the new line character(s) and indent.\ntoTokenString methods return a String. It is the caller’s responsibility to encode the returned String. According to RFC 8259 - 8.1 Character Encoding, your application must encode it using UTF-8 without BOM before saving them to a file or transmitted to a network.\ntoTokenBytes methods return a byte array. The returned byte array contains the JSON text encoded in UTF-8 without BOM.","title":"Output JSON text"},{"location":"/output.html#examples","text":"Let’s assume you constructed a JSON data structure with the code below and output the text with the last line where you specified ‘\\n’ as the new line character and two white spaces as indent.\nJSONValueObjectMutable obj = new JSONValueObjectMutable();\nobj.put(\"key1\", new JSONValueNumber(\"123\"));\nobj.put(new JSONValueString(\"key2\"), new JSONValueNumber(\"789\"));\nSystem.out.println(obj.toTokenString(\"\\n\", \"  \"));\nThen, you will get this result.\n{\n  \"key1\": 123,\n  \"key2\": 789\n}\nIf you do not specify new line or indent like this code,\nSystem.out.println(obj.toTokenString());\nthen you will get this one line result.\n{\"key1\":123,\"key2\":789}","title":"Examples"},{"location":"/json_pointer.html","text":"","title":"JSON Pointer"},{"location":"/json_pointer.html#json-pointer","text":"This library also implements JSON Pointer in accorance with RFC 6901.\nTo get a JSON value using a JSON Pointer, call JSONText#evaluate(String). Below is an example.\nJSONText jsText = JSONText.fromString(\n        \"{\" +\n        \"  \\\"key1\\\": \\\"value\\\", \" +\n        \"  \\\"key2\\\": [3, 1, 4], \" +\n        \"  \\\"key3\\\": true,\" +\n        \"  \\\"key4\\\": {\\\"key5\\\": \\\"hello!\\\" }\" +\n        \"} \");\n    JSONValue root = jsText.parse();\n\n    JSONValueString val1 = (JSONValueString) jsText.evaluate(\"/key1\");\n    System.out.println(val1.value());\n\n    JSONValueNumber val2 = (JSONValueNumber) jsText.evaluate(\"/key2/1\");\n    System.out.println(val2.toLong());\n\n    JSONValueString val3 = (JSONValueString) jsText.evaluate(\"/key4/key5\");\n    System.out.println(val3.value());\nNote Before your application calls evaluate(String) or its variant, it needs to explicitly call parse() or its variant and the JSON test must be parsed successfully. This is the design choice to allow your application code to separately handle possible exceptions caused by the JSON parser. Your application typically needs to call parse() only once and may evaluate JSON Pointers many times after that. You do not want to handle exceptions that may be caused by the JSON parser every time this library evaluates a JSON Pointer. If you want to make sure the JSON text has been parsed, your application may call isParsed() and call parse() if it has not been parsed.","title":"JSON Pointer"},{"location":"/json_pointer.html#uri-fragment-identifier-representation","text":"RFC 6901 - 6. URI Fragment Identifier Representation allows us to represent a JSON Pointer in a URI fragment identifier, which is a text starting from ‘#’ (0x23). Normally, JSON Pointer looks like /key1/5/key2. In URI fragment identifier, it turns to be #/key1/5/key2. However, RFC 6901 asks the application programs and libraries to check the media type (e.g. application/json) to judge if the JSON Pointer should be handled as a URI fragment identifier.\nThis library does not obtain the media type from the JSON text source because local file system does not typically provide it. Instead, your application programs to judge if JSON Pointers should be handled a URI fragment identifier. Once judged, pass true to the second argument of evaluate(String, boolean). Then, this library considers the given JSON Pointer as a URI fragument identifier, strips the first “#” (0x23) and evaluates the JSON Pointer in the normal way.","title":"URI Fragment Identifier Representation"},{"location":"/source.html","text":"","title":"Source Code"},{"location":"/source.html#source-code","text":"The source code of this library is available at GitHub.","title":"Source Code"},{"location":"/javadoc.html","text":"","title":"Javadoc"},{"location":"/javadoc.html#javadoc","text":"Javadoc of the latest version is available here.\nJavadoc of old versions is available as jar files in Maven Repository. For example, the javadoc jar file of version 0.0.6 can be found here.","title":"Javadoc"}]}